import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import {
	getContacts,
	createContact,
	updateContactProfile,
} from 'services/api/contactAPI';

function storeRefreshToken(token: string) {
	localStorage.setItem('refreshToken', token);
}

function removeRefreshToken() {
	localStorage.removeItem('refreshToken');
}

function getRefreshToken() {
	return localStorage.getItem('refreshToken');
}

export interface Contact {
	id?: string;
	email?: string;
	first_name?: string;
	last_name?: string;
	role?: string;
	createdAt?: string;
	token?: string | undefined;
	user_id?: string | undefined;
}

export interface ContactUpdateData {
	currentPassword: string;
	token: string | undefined;
	email?: string;
	password?: string;
	first_name?: string;
	last_name?: string;
	role?: string;
}

interface AuthState {
	userContacts?: any;
	profile?: Contact;
	loading: boolean;
	error: boolean;
	errorMessages: string[];
	accessToken?: string;
	refreshToken?: string | null;
	expiresIn?: number;
	tokenType?: string;
	currentRoute?: string;
}

const initialState: AuthState = {
	userContacts: [],
	profile: {
		id: undefined,
		first_name: undefined,
		last_name: undefined,
		email: undefined,
		role: undefined,
		createdAt: undefined,
	},
	loading: false,
	error: false,
	errorMessages: [],
};

export const getUserContacts = createAsyncThunk(
	'session/getUserContacts',
	async (payload: string, { rejectWithValue }) => {
		const response = await getContacts(payload);
		if (response.errors) {
			// The value we return becomes the `rejected` action payload
			return rejectWithValue(response);
		}
		// The value we return becomes the `fulfilled` action payload
		return response;
	}
);

export const createUserContact = createAsyncThunk(
	'session/createUserContact',
	async (payload: Contact, { rejectWithValue }) => {
		const response = await createContact(payload, payload.token);
		if (response.errors) {
			// The value we return becomes the `rejected` action payload
			return rejectWithValue(response);
		}
		// The value we return becomes the `fulfilled` action payload
		return response;
	}
);

export const updateProfile = createAsyncThunk(
	'session/updateProfile',
	async (payload: ContactUpdateData, { rejectWithValue }) => {
		const response = await updateContactProfile(
			payload.currentPassword,
			payload.token,
			payload?.email,
			payload?.password
		);
		if (response.errors) {
			// The value we return becomes the `rejected` action payload
			return rejectWithValue(response);
		}
		// The value we return becomes the `fulfilled` action payload
		return response;
	}
);

export const contactSlice = createSlice({
	name: 'contact',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		resetErrorState: (state) => {
			state.error = false;
			state.errorMessages = [];
		},
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		builder
			.addCase(getUserContacts.pending, (state) => {
				state.loading = true;
				state.error = false;
				state.errorMessages = [];
			})
			.addCase(getUserContacts.fulfilled, (state, action: any) => {
				state.userContacts = action.payload;

				state.loading = false;
				state.error = false;
				state.errorMessages = [];
			})
			.addCase(getUserContacts.rejected, (state, action: any) => {
				state.loading = false;
				state.error = true;
				state.errorMessages = action.payload.errors;
			})
			.addCase(createUserContact.pending, (state) => {
				state.loading = true;
				state.error = false;
				state.errorMessages = [];
			})
			.addCase(createUserContact.fulfilled, (state, action: any) => {
				state.userContacts = [
					...state.userContacts,
					{
						id: action.payload.id,
						first_name: action.payload.first_name,
						last_name: action.payload.last_name,
						email: action.payload.email,
						role: action.payload.role,
						createdAt: action.payload.created_at,
					},
				];

				state.loading = false;
				state.error = false;
				state.errorMessages = [];
			})
			.addCase(createUserContact.rejected, (state, action: any) => {
				state.loading = false;
				state.error = true;
				state.errorMessages = action.payload.errors;
			})
			.addCase(updateProfile.pending, (state) => {
				state.loading = true;
				state.error = false;
				state.errorMessages = [];
			})
			.addCase(updateProfile.fulfilled, (state, action: any) => {
				state.profile = {
					id: action.payload.id,
					first_name: action.payload.first_name,
					last_name: action.payload.last_name,
					email: action.payload.email,
					role: action.payload.role,
					createdAt: action.payload.created_at,
				};

				state.loading = false;
				state.error = false;
				state.errorMessages = [];
			})
			.addCase(updateProfile.rejected, (state, action: any) => {
				state.loading = false;
				state.error = true;
				state.errorMessages = action.payload.errors;
			});
	},
});

export const { resetErrorState } = contactSlice.actions;

export default contactSlice.reducer;
